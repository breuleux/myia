"""Implementation of the 'user_switch' operation."""

from functools import reduce

from .. import lib
from ..lib import (
    ANYTHING,
    CloneRemapper,
    GraphCloner,
    MyiaTypeError,
    force_pending,
    macro,
    union_simplify,
)
from ..xtype import Bool
from . import primitives as P


class _CastRemapper(CloneRemapper):

    def __init__(self,
                 graphs,
                 inlines,
                 manager,
                 relation,
                 graph_relation,
                 clone_constants,
                 graph_repl,
                 fv_replacements):
        """Initialize the GraphCloner."""
        super().__init__(
            graphs=graphs,
            inlines=inlines,
            manager=manager,
            relation=relation,
            graph_repl=graph_repl,
            graph_relation=graph_relation,
            clone_constants=clone_constants,
        )
        self.fv_replacements = fv_replacements

    def gen_fv(self, g, ng, fv):
        """Remap the free variables we want to remap."""
        if fv in self.fv_replacements:
            new = self.fv_replacements[fv]
            self.remap_node((g, fv), g, fv, ng, new, link=False)


@macro
async def user_switch(info, condref, tbref, fbref):
    """Implement the switch functionality generated by the parser.

    If user_switch finds a Union in the condition, it will infer the value of
    the condition for each type in the union. If the condition is necessarily
    true or false for some types, the type of the variable for the
    corresponding conditional branch will be set to these types.
    """
    engine = info.engine
    g = info.graph

    async def type_trials(focus, opnode, argrefs):
        """Handle `user_switch(hastype(x, typ), tb, fb)`.

        We want to evaluate tb in a context where x has type typ and fb
        in a context where it doesn't.
        """
        def cond_trial(cg, opt):
            # For each possible type we make a "cond trial" which replaces the
            # focus input in the condition function by one that's cast to the
            # type. We can thus check if the value of the condition depends
            # directly on the type.
            return cg.apply(opnode,
                            *nodes[:focus],
                            cg.apply(P.unsafe_static_cast, nodes[focus], opt),
                            *nodes[focus + 1:])

        async def wrap(branch_ref, branch_type):
            # We transform branch_graph into a new graph which refers to a cast
            # version of x. We also transform all of the children of x's graph
            # so that closures called in the branch also refer to the cast
            # version of x.
            branch_graph = branch_ref.node.value
            if branch_graph not in xg.scope:
                return branch_graph
            rval = branch_graph.make_new(relation='copy')
            cast = rval.apply(P.unsafe_static_cast, xref.node, branch_type)
            cl = GraphCloner(
                *xg.children,
                total=False,
                graph_repl={branch_graph: rval},
                remapper_class=_CastRemapper.partial(
                    fv_replacements={xref.node: cast}
                )
            )
            assert rval is cl[branch_graph]
            engine.mng.add_graph(rval)
            return rval

        nodes = [ref.node for ref in argrefs]
        xref = argrefs[focus]
        fulltype = await xref.get()
        assert isinstance(fulltype, lib.AbstractUnion)

        xg = xref.node.graph
        cg = cond.graph
        cond_trials = [cond_trial(cg, t) for t in
                       await force_pending(fulltype.options)]
        results = [await engine.ref(node, ctx).get()
                   for node in cond_trials]

        groups = {True: [], False: [], ANYTHING: []}

        for t, result in zip(fulltype.options, results):
            assert isinstance(result, lib.AbstractScalar)
            assert result.xtype() is Bool
            value = result.xvalue()
            groups[value].append(t)

        if groups[ANYTHING]:
            return await default()

        tbtyp = union_simplify(groups[True])
        fbtyp = union_simplify(groups[False])

        if tbtyp is None:
            return fbref
        elif fbtyp is None:
            return tbref
        else:
            new_conds = [g.apply(P.hastype, xref.node, t)
                         for t in groups[True]]
            new_cond = reduce(lambda x, y: g.apply(P.bool_or, x, y),
                              new_conds)
            new_tb = await wrap(tbref, tbtyp)
            new_fb = await wrap(fbref, fbtyp)
            return g.apply(P.switch, new_cond, new_tb, new_fb)

    async def default():
        _, _, tb, fb = info.outref.node.inputs
        return g.apply(P.switch, cond, tb, fb)

    for branch_ref in [tbref, fbref]:
        if not branch_ref.node.is_constant_graph():
            raise MyiaTypeError(
                'Branches of switch must be functions when the condition'
                ' is hastype on a Union.'
            )

    cond = condref.node
    ctx = condref.context

    condt = await condref.get()
    if not engine.check_predicate(Bool, condt):
        to_bool = engine.resources.convert(bool)
        cond = (cond.graph or g).apply(to_bool, cond)

    if cond.is_apply():
        opnode, *args = cond.inputs
        opref = engine.ref(opnode, ctx)
        ops = (await opref.get()).get_sync()
        if len(ops) == 1:
            op, = ops
            argrefs = [engine.ref(a, ctx) for a in args]
            argtypes = [await arg.get() for arg in argrefs]
            for i, arg in enumerate(argtypes):
                if isinstance(arg, lib.AbstractUnion):
                    return await type_trials(i, opnode, argrefs)

    return await default()


__operation_defaults__ = {
    'name': 'user_switch',
    'registered_name': 'user_switch',
    'mapping': user_switch,
    'python_implementation': None,
}
